#### Секционирование таблицы

* 1) Подключаем базу:
 >>
 psql -U postgres -d demo -f /tmp/demo.sql
 
* 2) Смотрим таблицы:
 >>
 \dt
 \d bookings
 Подробнее:  
 SELECT column_name, data_type, is_nullable, column_default  
 FROM information_schema.columns  
 WHERE table_name = 'bookings';   
 
* 3) Определите, какие данные в таблице bookings или других таблицах имеют логическую привязку к диапазонам, по которым можно провести секционирование (например, дата бронирования, рейсы)
 
 flights - в таблице 10 столбцов:
 
 flight_id  - идентификатор рейса  
 scheduled_departure - запланированная дата и время вылета   
 scheduled_arrival  - запланированная дата и время прибытия  
 actual_departure  - фактическая дата и время вылета  
 actual_arrival  - фактическая дата и время прибытия  
 arrival_airport - аэропорт прибытия   
 flight_no  - номер рейса  
 status  - статус рейса  
 aircraft_code  - код самолета  
 departure_airport  - аэропорт вылета  

* Основной критерий для секционирования: временные диапазоны, потмоу что большинство запросов к таблице связаны с датами и времене -   
  например: время вылета\прилета, анализ  рейсов за период, выполненные или отмененные рейсы и т.п.
  
 Выберим поле scheduled_departure, так как множество операций строится на планировании вылетов:
 
* Определитесь с типом секционирования, которое наилучшим образом подходит для ваших данных:

 Для выбранного поля scheduled_departure, наиболее подходящий тип секционирования — это по диапазону (Range partitioning), что ускорит выполнение запросов за определенные периоды.
  
* 4) Создание секционированной таблицы:
 >>
 CREATE TABLE flights_range (  
    flight_id SERIAL,  
    scheduled_departure TIMESTAMP NOT NULL,  
    scheduled_arrival TIMESTAMP,  
    actual_departure TIMESTAMP,  
    actual_arrival TIMESTAMP,  
    arrival_airport VARCHAR(10),  
    departure_airport VARCHAR(10),  
    flight_no VARCHAR(10),  
    status VARCHAR(20),  
    aircraft_code VARCHAR(10),  
    PRIMARY KEY (flight_id, scheduled_departure)  
) PARTITION BY RANGE (scheduled_departure);   
 
* Создаем разделы подтаблицы:
 >> 
 CREATE TABLE flights_2017_q1 PARTITION OF flights_range    
 FOR VALUES FROM ('2017-07-01') TO ('2017-07-010');    
 
 CREATE TABLE flights_2017_q11 PARTITION OF flights_range  
 FOR VALUES FROM ('2017-07-010') TO ('2017-07-031');  
 
 CREATE TABLE flights_2017_q12 PARTITION OF flights_range  
 FOR VALUES FROM ('2017-08-01') TO ('2017-08-015');  
 
 CREATE TABLE flights_2017_q13 PARTITION OF flights_range  
 FOR VALUES FROM ('2017-08-015') TO ('2017-08-030');  
  
 CREATE TABLE flights_2017_q14 PARTITION OF flights_range    
 FOR VALUES FROM ('2017-09-01') TO ('2017-09-030');  
 
* Миграция данных: 
 >>
 INSERT INTO flights_range (flight_id, scheduled_departure, scheduled_arrival, actual_departure, actual_arrival, arrival_airport, departure_airport, flight_no, status, aircraft_code)
 SELECT flight_id, scheduled_departure, scheduled_arrival, actual_departure, actual_arrival, arrival_airport, departure_airport, flight_no, status, aircraft_code
 FROM flights;
 
* Убедитесь, что все данные правильно распределены по секциям:  
 >> (Вывод списка всех партиций и их диапазоны)
 SELECT inhrelid::regclass AS partition_name  
 FROM pg_inherits  
 WHERE inhparent = 'flights_range'::regclass;  
 
* Проверить диапазон каждой партиции:
 >>
 SELECT pg_get_expr(pg_class.relpartbound, pg_class.oid)
 FROM pg_class
 WHERE relname = 'flights_2017_q1'; (и другие)   
 
* 5) Проверяем и тестируем наличие данных в диапазоне и вне его:
 >>
 SELECT *  
 FROM flights_range  
 WHERE scheduled_departure < '2017-07-01' OR scheduled_departure >= '2017-09-01';   
 
 SELECT *  
 FROM flights_range  
 WHERE scheduled_departure < '2017-06-01' OR scheduled_departure >= '2017-09-30';  
 
* Проверьте, что операции вставки, обновления и удаления работают корректно:
 >> 
* Вставка
 INSERT INTO flights_range (scheduled_departure)  
 VALUES ('2017-07-11 00:22:22');  
 
 INSERT INTO flights_range (scheduled_departure)
 VALUES ('2017-07-12 00:44:44');
* Удаление:
>> 
 DELETE FROM flights_range  
 WHERE scheduled_departure = '2017-07-10 00:22:22';  
 
* Обновление:  
 >>
 UPDATE flights_range  
 SET scheduled_departure = '2017-07-11 03:00:00'  
 WHERE scheduled_departure = '2017-07-10 02:50:00';  
  
*  Проверяем распределение данных по партициям:
 >>   
 SELECT relname AS partition_name,  
       pg_get_expr(pg_class.relpartbound, pg_class.oid) AS range_definition,  
       COUNT(*) AS row_count  
 FROM pg_inherits  
 JOIN pg_class ON inhrelid = pg_class.oid  
 WHERE inhparent = 'flights_range'::regclass  
 GROUP BY relname, range_definition;  
 
* При тестиовании различных запросов, я получал значения  в диапазоне от 220 мс до 450 мс, вероятно из за  довольно быстрой виртуалки 4 ядра, 32ГБ, ssd., особой разницы в запросах я не заметил.   
 Но я понимаю, что секционирование улучшает производительность, особенно это будет заметно на больших данных и частых запросах, с ее помощью PSQL может определить к каким партициям обращаться для поиска нужных данных, ускоряет вставку и удаление данных, составление отчетов, оптимизирует индексы, позволяет перемещать и архивировать отдельные данные, что ускоряет резервное копирование. 

________________
Скрипкин А.В.

