#### Домашнее задание Блокировки
* 1) Настройте сервер так, чтобы в журнал сообщений сбрасывалась информация о блокировках, удерживаемых более 200 миллисекунд. Воспроизведите ситуацию, при которой в журнале появятся такие сообщения.  
 >"ALTER SYSTEM SET deadlock_timeout TO 200" - выставить таймаут  
 log_lock_waits = on - включить логирование блокировоко  
 "select pg_reload_conf()" - перезагрузить конфиг  
 "show deadlock_timeout" - посмотреть таймаут  
* создаем таблицу и вставляем значения  
 >"create table test1(id int primary key,message text)"
 "insert into test1 values (1, '321')"
 "insert into test1 values (2, '123')"
* Сессия 1  
>BEGIN;
LOCK TABLE test1 IN ACCESS EXCLUSIVE MODE; - не комитим

* Сессия 2  
>BEGIN;
LOCK TABLE test1 IN ACCESS EXCLUSIVE MODE; - WARNING:  there is already a transaction in progress (ждет выполнения предыдущей транзакции)

* Ожидаем и комитим первую транзу
COMMIT;
* В журнале видим сообщения:  
WARNING:  there is already a transaction in progress
LOG:  process 2646 still waiting for AccessExclusiveLock on relation 16471 of database 5 after 200.028 ms
DETAIL:  Process holding the lock: 2644. Wait queue: 2646.
STATEMENT:  BEGIN;
LOCK TABLE test1 IN ACCESS EXCLUSIVE MODE;
LOG:  process 2646 acquired AccessExclusiveLock on relation 16471 of database 5 after 153374.765 ms
STATEMENT:  BEGIN;
LOCK TABLE test1 IN ACCESS EXCLUSIVE MODE;

* 2) Смоделируйте ситуацию обновления одной и той же строки тремя командами UPDATE в разных сеансах. Изучите возникшие блокировки в представлении pg_locks и убедитесь, что все они понятны. Пришлите список блокировок и объясните, что значит каждая.  
 Создать таблицу:
>> CREATE TABLE test_lock (
    id SERIAL PRIMARY KEY,
    data TEXT
);

INSERT INTO test_lock (data) VALUES ('initial');
* Первый сеанс:
>> BEGIN;
UPDATE test_lock SET data = 'update by session 1' WHERE id = 1;
-- без комита
* Второй сеанс:
>> BEGIN;
UPDATE test_lock SET data = 'update by session 2' WHERE id = 1;
-- без комита, ожидает выполнение первой
* Третий сеанс
>> BEGIN;
UPDATE test_lock SET data = 'update by session 3' WHERE id = 1;
-- без комита, ожидает выполнение первой и второй

* Посмотреть pid транзакций и доп информацию:  
       > SELECT pid, usename, datname, application_name, xact_start, now() - xact_start AS transaction_duration  
        FROM pg_stat_activity  
        WHERE pid <> pg_backend_pid()  
        AND state <> 'idle in transaction  '
        ORDER BY xact_start;  
 Вывод pid:  
 Сессиия1 - 81975  
 Сессиия2 - 82212  
 Сессиия3 - 82257  
 
* Посмотреть активные блокировки:  
>SELECT   
    pid,  
    locktype,  
    relation::regclass AS relation_name,  
    page,  
    tuple,  
    virtualtransaction,  
    transactionid,  
    mode,  
    granted,  
    fastpath  
FROM pg_locks  
WHERE NOT granted;  
* Или:  
		SELECT blocked_locks.pid     AS blocked_pid,  
         blocked_activity.usename  AS blocked_user,  
         blocking_locks.pid     AS blocking_pid,  
         blocking_activity.usename AS blocking_user,  
         blocked_activity.query    AS blocked_statement,  
         blocking_activity.query   AS current_statement_in_blocking_process,  
         blocked_activity.application_name AS blocked_application  
         blocking_activity.application_name AS blocking_application  
   FROM  pg_catalog.pg_locks         blocked_locks  
    JOIN pg_catalog.pg_stat_activity blocked_activity  ON blocked_activity.pid = blocked_locks.pid  
    JOIN pg_catalog.pg_locks         blocking_locks   
        ON blocking_locks.locktype = blocked_locks.locktype  
        AND blocking_locks.DATABASE IS NOT DISTINCT FROM blocked_locks.DATABASE  
        AND blocking_locks.relation IS NOT DISTINCT FROM blocked_locks.relation  
        AND blocking_locks.page IS NOT DISTINCT FROM blocked_locks.page  
        AND blocking_locks.tuple IS NOT DISTINCT FROM blocked_locks.tuple  
        AND blocking_locks.virtualxid IS NOT DISTINCT FROM blocked_locks.virtualxid  
        AND blocking_locks.transactionid IS NOT DISTINCT FROM blocked_locks.transactionid  
        AND blocking_locks.classid IS NOT DISTINCT FROM blocked_locks.classid  
        AND blocking_locks.objid IS NOT DISTINCT FROM blocked_locks.objid  
        AND blocking_locks.objsubid IS NOT DISTINCT FROM blocked_locks.objsubid  
        AND blocking_locks.pid != blocked_locks.pid  
 
    JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
   WHERE NOT blocked_locks.GRANTED;  
   
* Блокироанные и блокирующие процессы:  
>SELECT   
    blocked.pid AS blocked_pid,  
    blocked.query AS blocked_query,  
    blocking.pid AS blocking_pid,  
    blocking.query AS blocking_query  
FROM pg_stat_activity blocked  
JOIN pg_locks blocked_lock ON blocked.pid = blocked_lock.pid  
JOIN pg_locks blocking_lock ON   
      blocked_lock.locktype = blocking_lock.locktype AND  
      blocked_lock.database IS NOT DISTINCT FROM blocking_lock.database AND  
      blocked_lock.relation IS NOT DISTINCT FROM blocking_lock.relation AND  
      blocked_lock.page = blocking_lock.page AND  
      blocked_lock.tuple = blocking_lock.tuple AND  
      blocked_lock.virtualtransaction != blocking_lock.virtualtransaction AND  
      blocking_lock.granted = true AND   
      blocked_lock.granted = false  
JOIN pg_stat_activity blocking ON blocking.pid = blocking_lock.pid;  

  Вывод: сеанс 81975 блокирует 82212, 82212 блокирует 82257
  
* Посмотреть все блокировки:  
> SELECT   
    l.pid,  
    a.query,  
    a.state,  
    l.locktype,  
    l.mode,  
    l.granted,  
    c.relname AS relation_name  
FROM pg_locks l  
JOIN pg_stat_activity a ON l.pid = a.pid  
LEFT JOIN pg_class c ON c.oid = l.relation  
ORDER BY l.pid;  

* 3)Воспроизведите взаимоблокировку трех транзакций. Можно ли разобраться в ситуации постфактум, изучая журнал сообщений ?  
 Создаем таблицу:
>CREATE TABLE test_deadlock (
    id SERIAL PRIMARY KEY,
    data TEXT
);

>INSERT INTO test_deadlock (data) VALUES ('row1'), ('row2'), ('row3');
* Подготовка к  взаимоблокировке:
 Сессиия1:
BEGIN;
-- Захватывает блокировку на строке с id=1
UPDATE test_deadlock SET data='T1' WHERE id=1;
-- Не коммитим, чтобы удерживать блокировку
 Сессиия2:
BEGIN;
-- Захватывает блокировку на строке с id=2
UPDATE test_deadlock SET data='T2' WHERE id=2;
 Сессиия3:
BEGIN;
-- Захватывает блокировку на строке с id=3
UPDATE test_deadlock SET data='T3' WHERE id=3;

* Создаем взаимоблокировку:
 Сессиия1:
UPDATE test_deadlock SET data='T1-try' WHERE id=2;
ждёт освобождения строки с id=2, которая заблокирована сессией 2
 Сессиия2:
UPDATE test_deadlock SET data='T2-try' WHERE id=3;
ждёт освобождения строки с id=3, которая заблокирована транзакцией 3
 Сессиия3:
UPDATE test_deadlock SET data='T3-try' WHERE id=1;
ждёт освобождения строки с id=1, которая заблокирована транзакцией 1.  

### Получаем сообщение:
ERROR:  Process 82981 waits for ShareLock on transaction 4371372; blocked by process 82976.
Process 82976 waits for ShareLock on transaction 4371373; blocked by process 82978.
Process 82978 waits for ShareLock on transaction 4371374; blocked by process 82981.deadlock detected 

ERROR:  deadlock detected
SQL state: 40P01
Detail: Process 82981 waits for ShareLock on transaction 4371372; blocked by process 82976.
Process 82976 waits for ShareLock on transaction 4371373; blocked by process 82978.
Process 82978 waits for ShareLock on transaction 4371374; blocked by process 82981.
Hint: See server log for query details.
Context: while updating tuple (0,1) in relation "test_deadlock" 

### Задание со звездочкой*
* 4) Могут ли две транзакции, выполняющие единственную команду UPDATE одной и той же таблицы (без where), заблокировать друг друга?
Могут, потому что UPDATE без WHERE — это обновление всех строк таблицы и каждая транзакция захватывает эксклюзивную блокировку на таблице во время выполнения UPDATE, если обе транзакции начать одновременно  обновляя одну таблицу, то они попадут в очередь др за другой блокируя друг друга до завершения.

Пример:  
 Создаем таблицу:  
>CREATE TABLE test_deadlock (
    id SERIAL PRIMARY KEY,
    data TEXT
);

>INSERT INTO test_deadlock (data) VALUES ('row1'), ('row2');  
>
 Сессиия1:  
>BEGIN;
UPDATE test_deadlock SET data='T1' WHERE id=1;  
-- Не коммитим, чтобы удерживать блокировку на строке 1  
 Сессиия2:  
> BEGIN;
UPDATE test_deadlock SET data='T2' WHERE id=2;  
-- Не коммитим, чтобы удерживать блокировку на строке 2

 Создаем взаимоблокировку:  
 Сессиия1:  
 -- Попытка обновить вторую строку (id=2), которая заблокирована второй транзакцией
>UPDATE test_deadlock SET data='T1-try' WHERE id=2;
>    
 Сессиия2:  
 -- Попытка обновить первую строку (id=1), которая заблокирована первой транзакцией  
>UPDATE test_deadlock SET data='T2-try' WHERE id=1;

 Вывод: Первая транзакция держит блокировку на строке с id=1 и пытается обновить строку с id=2, вторая транзакция держит блокировку на строке с id=2 и пытается обновить строку с id=1, обе ждут друг друга — возникает взаимоблокировка
 _________________
 Скрипкин А.В.

 

